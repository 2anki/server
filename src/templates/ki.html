<!DOCTYPE html>
<html>

<head>
        <title>Ki Interface</title>
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <script src="https://unpkg.com/htmx.org@1.9.10"></script>
        <!-- Hotjar Tracking Code for https://2anki.net -->
        <script>
                (function (h, o, t, j, a, r) {
                        h.hj = h.hj || function () {
                                (h.hj.q = h.hj.q || []).push(arguments);
                        };
                        h._hjSettings = { hjid: 2603407, hjsv: 6 };
                        a = o.getElementsByTagName('head')[0];
                        r = o.createElement('script');
                        r.async = 1;
                        r.src = t + h._hjSettings.hjid + j + h._hjSettings.hjsv;
                        a.appendChild(r);
                })(window, document, 'https://static.hotjar.com/c/hotjar-', '.js?sv=');
        </script>

        <style>
                :root {
                        /* Color System */
                        --primary: #4F46E5;
                        --primary-light: #818CF8;
                        --primary-dark: #4338CA;
                        --bg-primary: #ffffff;
                        --bg-secondary: #F9FAFB;
                        --text-primary: #111827;
                        --text-secondary: #4B5563;
                        --border-color: #E5E7EB;
                        --hover-bg: #5397f5;
                        --success: #10B981;
                        --error: #EF4444;
                        --warning: #F59E0B;

                        /* Shadows */
                        --shadow-sm: 0 1px 2px 0 rgb(0 0 0 / 0.05);
                        --shadow-md: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
                        --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1), 0 4px 6px -4px rgb(0 0 0 / 0.1);

                        /* Border Radius */
                        --radius-sm: 0.375rem;
                        --radius-md: 0.5rem;
                        --radius-lg: 0.75rem;

                        /* Spacing */
                        --spacing-xs: 0.5rem;
                        --spacing-sm: 0.75rem;
                        --spacing-md: 1rem;
                        --spacing-lg: 1.5rem;
                        --spacing-xl: 2rem;

                        /* Typography */
                        --font-ui: 'Inter', system-ui, -apple-system, sans-serif;
                        --font-mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;

                        /* Transitions */
                        --transition-fast: 150ms cubic-bezier(0.4, 0, 0.2, 1);
                        --transition-normal: 200ms cubic-bezier(0.4, 0, 0.2, 1);

                        /* Layout */
                        --header-height: 4rem;
                        --editor-height: 250px;
                        --container-max-width: 65rem;
                }

                * {
                        box-sizing: border-box;
                        margin: 0;
                        padding: 0;
                }

                body {
                        background: var(--bg-secondary);
                        font-family: var(--font-ui);
                        color: var(--text-primary);
                        line-height: 1.6;
                        font-size: 16px;
                        -webkit-font-smoothing: antialiased;
                        min-height: 100vh;
                        width: 100%;
                        overflow-x: hidden;
                }

                .container {
                        width: 100%;
                        margin: 0 auto;
                        display: flex;
                        flex-direction: column;
                        min-height: 100vh;
                        padding-bottom: calc(180px + var(--spacing-lg));
                        overflow-x: hidden;
                        max-width: var(--container-max-width);
                }

                @media (max-width: 600px) {
                        .container {
                                padding: 0;
                        }
                }

                .header {
                        position: sticky;
                        top: 0;
                        z-index: 100;
                        background: rgba(255, 255, 255, 0.8);
                        backdrop-filter: blur(8px);
                        -webkit-backdrop-filter: blur(8px);
                        border-bottom: 1px solid var(--border-color);
                        padding: 12px 24px;
                        margin-bottom: 24px;
                }

                .header-content {
                        max-width: 900px;
                        margin: 0 auto;
                        display: flex;
                        justify-content: space-between;
                        align-items: center;
                }

                .logo {
                        font-size: 48px;
                        font-weight: 600;
                        color: var(--text-primary);
                        text-decoration: none;
                }

                .header-right {
                        display: flex;
                        gap: 16px;
                        align-items: center;
                }

                .header-link {
                        color: var(--text-secondary);
                        text-decoration: none;
                        font-size: 14px;
                        font-weight: 500;
                        padding: 6px 12px;
                        border-radius: var(--radius-md);
                        transition: var(--transition);
                }

                .header-link:hover {
                        color: var(--text-primary);
                        background: var(--bg-secondary);
                }

                .editor-container {
                        position: relative;
                        width: 100%;
                        max-width: 600px;
                        margin: var(--spacing-lg) auto;
                        background: var(--bg-primary);
                        border: 1px solid var(--border-color);
                        border-radius: var(--radius-lg);
                        box-shadow: var(--shadow-lg);
                        overflow: hidden;
                        transition: var(--transition-normal);
                        backdrop-filter: blur(8px);
                }

                .editor-container:hover {
                        box-shadow: var(--shadow-xl);
                        transform: translateY(-2px);
                }

                .drag-overlay {
                        display: none;
                        position: absolute;
                        top: 0;
                        left: 0;
                        right: 0;
                        bottom: 0;
                        background: rgba(83, 121, 245, 0.1);
                        align-items: center;
                        justify-content: center;
                        font-size: 16px;
                        color: var(--primary);
                        pointer-events: none;
                }

                .editor-container.drag-over .drag-overlay {
                        display: flex;
                }

                textarea {
                        width: 100%;
                        min-height: 180px;
                        padding: var(--spacing-lg);
                        border: none;
                        font-family: var(--font-ui);
                        font-size: 1rem;
                        line-height: 1.6;
                        color: var(--text-primary);
                        resize: none;
                        background: transparent;
                        transition: var(--transition-normal);
                }

                textarea::placeholder {
                        color: var(--text-secondary);
                }

                .file-input {
                        border-top: 1px solid var(--border-color);
                        padding: var(--spacing-md);
                        background: var(--bg-primary);
                        display: grid;
                        grid-template-columns: auto 1fr auto;
                        gap: var(--spacing-md);
                        align-items: center;
                }

                .file-input-left {
                        display: flex;
                        align-items: center;
                        gap: var(--spacing-sm);
                }

                .file-input-center {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                }

                .file-input-right {
                        display: flex;
                        align-items: center;
                        gap: var(--spacing-sm);
                }

                input[type="file"] {
                        display: none;
                }

                .upload-button {
                        cursor: pointer;
                        display: inline-flex;
                        align-items: center;
                        justify-content: center;
                        gap: var(--spacing-sm);
                        padding: var(--spacing-sm) var(--spacing-md);
                        border-radius: var(--radius-md);
                        background: var(--bg-secondary);
                        border: 1px solid var(--border-color);
                        color: var(--text-secondary);
                        font-size: 0.875rem;
                        font-weight: 500;
                        min-width: 36px;
                        height: 36px;
                        transition: all var(--transition-fast);
                }

                .upload-button:hover {
                        background: var(--hover-bg);
                        color: white;
                        border-color: var(--hover-bg);
                        transform: translateY(-1px);
                        box-shadow: var(--shadow-sm);
                }

                .upload-button img {
                        width: 20px;
                        height: 20px;
                }

                .file-list-container {
                        width: 100%;
                        padding: 0 16px;
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8px;
                        align-items: center;
                }

                #file-list {
                        display: flex;
                        flex-wrap: wrap;
                        gap: 8px;
                        align-items: center;
                }

                .download-button {
                        display: inline-flex;
                        align-items: center;
                        gap: 8px;
                        padding: 12px 24px;
                        background: var(--primary);
                        color: white;
                        border: none;
                        border-radius: var(--radius-md);
                        font-size: 16px;
                        font-weight: 500;
                        cursor: pointer;
                        transition: background 0.2s ease;
                        box-shadow: var(--shadow-sm);
                }

                .download-button:hover {
                        background: #1a6fc9;
                }

                .download-button img {
                        width: 24px;
                        height: 24px;
                        filter: brightness(0) invert(1);
                }

                .file-chip {
                        display: inline-flex;
                        align-items: center;
                        gap: var(--spacing-xs);
                        background: var(--bg-secondary);
                        border: 1px solid var(--border-color);
                        border-radius: var(--radius-md);
                        padding: var(--spacing-xs) var(--spacing-sm);
                        font-size: 0.875rem;
                        color: var(--text-secondary);
                        transition: var(--transition-fast);
                }

                .file-chip:hover {
                        border-color: var(--primary);
                        background: var(--bg-primary);
                        color: var(--primary);
                        transform: translateY(-1px);
                }

                .file-chip button {
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        padding: 2px;
                        border: none;
                        background: none;
                        cursor: pointer;
                        color: inherit;
                        border-radius: 50%;
                        transition: var(--transition-fast);
                }

                .file-chip button:hover {
                        background: var(--hover-bg);
                        color: var(--error);
                }

                .processing-state {
                        background: var(--bg-primary);
                        border: 1px solid var(--border-color);
                        border-radius: var(--radius-lg);
                        padding: var(--spacing-lg);
                        margin: var(--spacing-md) auto;
                        max-width: 600px;
                        box-shadow: var(--shadow-lg);
                        animation: fadeSlideUp 0.3s var(--transition-normal);
                }

                .processing-state .icon {
                        width: 32px;
                        height: 32px;
                        display: flex;
                        align-items: center;
                        justify-content: center;
                        border-radius: var(--radius-md);
                        background: var(--primary-light);
                        color: white;
                }

                .processing-state .title {
                        font-size: 1.125rem;
                        font-weight: 600;
                        display: flex;
                        align-items: center;
                        gap: var(--spacing-sm);
                        margin-bottom: var(--spacing-sm);
                        color: var(--text-primary);
                }

                .processing-state .subtitle {
                        color: var(--text-secondary);
                        font-size: 0.875rem;
                }

                .processing-state .progress {
                        margin-top: var(--spacing-md);
                        height: 4px;
                        background: var(--bg-secondary);
                        border-radius: 2px;
                        overflow: hidden;
                }

                .processing-state .progress-bar {
                        height: 100%;
                        background: var(--primary);
                        border-radius: 2px;
                        transition: width var(--transition-normal);
                }

                .processing-state .spinner {
                        width: 16px;
                        height: 16px;
                        border: 2px solid var(--primary-light);
                        border-top: 2px solid var(--primary);
                        border-radius: 50%;
                        animation: spin 0.8s linear infinite;
                }

                .status-message {
                        font-size: 14px;
                        color: var(--text-secondary);
                        margin: 4px 0;
                }

                .processing-state .cancel-button {
                        padding: 6px 12px;
                        border: 1px solid var(--border-color);
                        border-radius: var(--radius-md);
                        background: var(--bg-primary);
                        color: var(--text-secondary);
                        font-size: 13px;
                        cursor: pointer;
                        transition: var(--transition);
                }

                .processing-state .cancel-button:hover {
                        background: var(--hover-bg);
                        color: var(--text-primary);
                }

                .input-container {
                        position: fixed;
                        bottom: 0;
                        left: 0;
                        right: 0;
                        padding: var(--spacing-md);
                        background: var(--bg-secondary);
                        backdrop-filter: blur(12px);
                        -webkit-backdrop-filter: blur(12px);
                        border-top: 1px solid var(--border-color);
                        z-index: 1000;
                }

                .opacity-0 {
                        opacity: 0;
                }

                .fade-in {
                        opacity: 1;
                        transition: opacity 0.2s ease-out;
                }

                .positioned {
                        transform: translateY(var(--offset));
                }

                .scrollable {
                        height: var(--height);
                }

                .debug-active {
                        background: var(--hover-bg);
                        color: var(--primary);
                }

                .virtual-item {
                        position: relative;
                        transition: transform 0.2s ease-out;
                }

                .visible {
                        opacity: 1;
                        visibility: visible;
                }

                .cancelled {
                        opacity: 0;
                        visibility: hidden;
                        transition: opacity 0.3s ease-out, visibility 0.3s ease-out;
                }

                .debug-title {
                        font-weight: 600;
                        margin-bottom: 4px;
                }

                .debug-content {
                        font-size: 14px;
                        color: var(--text-secondary);
                }

                .debug-list {
                        list-style: none;
                        padding: 0;
                        margin: 4px 0;
                }

                .spinner {
                        width: 16px;
                        height: 16px;
                        border: 2px solid var(--bg-secondary);
                        border-top-color: var(--primary);
                        border-radius: 50%;
                        animation: spin 1s linear infinite;
                }

                .progress-bar {
                        height: 2px;
                        background: var(--primary);
                        width: 0;
                        transition: width 0.3s ease-out;
                }

                @keyframes spin {
                        to {
                                transform: rotate(360deg);
                        }
                }

                @keyframes fadeSlideUp {
                        from {
                                opacity: 0;
                                transform: translateY(10px);
                        }

                        to {
                                opacity: 1;
                                transform: translateY(0);
                        }
                }

                /* Responsive Design */
                @media (max-width: 768px) {
                        :root {
                                --spacing-lg: 1.25rem;
                                --spacing-md: 0.875rem;
                        }

                        .container {
                                padding: var(--spacing-md);
                        }

                        .editor-container {
                                margin: var(--spacing-md) auto;
                        }

                        .file-input {
                                padding: var(--spacing-sm);
                        }

                        .upload-button {
                                padding: var(--spacing-xs) var(--spacing-sm);
                        }
                }

                /* Accessibility */
                @media (prefers-reduced-motion: reduce) {
                        * {
                                animation-duration: 0.01ms !important;
                                animation-iteration-count: 1 !important;
                                transition-duration: 0.01ms !important;
                                scroll-behavior: auto !important;
                        }
                }

                .virtual-item:focus-within {
                        outline: 2px solid var(--primary);
                        outline-offset: 2px;
                }

                button:focus-visible,
                textarea:focus-visible {
                        outline: 2px solid var(--primary);
                        outline-offset: 2px;
                }

                .history-select {
                        padding: var(--spacing-xs) var(--spacing-sm);
                        border: 1px solid var(--border-color);
                        border-radius: var(--radius-md);
                        background: var(--bg-secondary);
                        color: var(--text-secondary);
                        font-size: 0.875rem;
                        cursor: pointer;
                        transition: var(--transition-fast);
                }

                .history-select:hover {
                        border-color: var(--hover-bg);
                        color: var(--hover-bg);
                }

                .history-select:focus {
                        outline: none;
                        border-color: var(--hover-bg);
                        box-shadow: 0 0 0 2px rgba(83, 151, 245, 0.1);
                }

                .cards-container {
                        width: 100%;
                        max-width: 600px;
                        margin: 0 auto;
                        padding: var(--spacing-md);
                }
        </style>
</head>

<body>
        <div class="container">
                <div id="results">
                        <div class="cards-container"></div>
                </div>

                <div class="input-container" id="input-container">
                        <div class="editor-container">
                                <div class="drag-overlay">Drop files here</div>
                                <textarea placeholder="Paste your content here or drag your files here..." name="text"
                                        id="text" onkeydown="handleKeyDown(event)"></textarea>
                                <div class="file-input">
                                        <div class="file-input-left">
                                                <button type="button" class="upload-button"
                                                        title="Upload Files (Shift + A)"
                                                        onclick="document.getElementById('files').click()">📎</button>
                                                <button type="button" class="upload-button" title="Submit Text"
                                                        onclick="generateFlashcards()">📝</button>
                                                <input type="file" id="files" name="files" multiple>
                                        </div>
                                        <div class="file-input-center">
                                                <button type="button" class="upload-button" title="Download Deck"
                                                        onclick="downloadDeckWithName()">
                                                        <img src="https://upload.wikimedia.org/wikipedia/commons/3/3d/Anki-icon.svg"
                                                                style="width: 24px; height: 24px; vertical-align: middle;"
                                                                alt="Download">
                                                </button>
                                        </div>
                                        <div class="file-input-right">
                                                <select class="history-select" id="session-history"
                                                        onchange="loadSession(this.value)">
                                                        <option value="">Current Session</option>
                                                </select>
                                                <button type="button" class="upload-button" title="Delete Session"
                                                        onclick="deleteSession()">🗑️</button>
                                                <button type="button" class="upload-button" title="New Session"
                                                        onclick="startNewSession()">🆕</button>
                                        </div>
                                </div>
                        </div>
                </div>
        </div>

        <script>
                // Cache frequently used elements
                const processingStateEl = document.querySelector('.processing-state');
                const statusMessageEl = document.querySelector('.status-message');
                const textareaEl = document.querySelector('textarea[name="text"]');
                const uploadButtonEl = document.querySelector('.file-input-left .upload-button');
                const resultsEl = document.querySelector('.cards-container');

                // Override console methods to send status messages
                const originalConsole = {
                        log: console.log,
                        error: console.error,
                        warn: console.warn,
                        info: console.info
                };

                function sendStatusMessage(message) {
                        const statusMessages = document.querySelector('.status-message');
                        if (statusMessages) {
                                const newMessage = document.createElement('div');
                                newMessage.textContent = message;
                                newMessage.classList.add('status-message');
                                statusMessages.appendChild(newMessage);

                                while (statusMessages.children.length > 3) {
                                        statusMessages.removeChild(statusMessages.firstChild);
                                }

                                newMessage.scrollIntoView({ behavior: 'smooth' });
                        }
                }

                console.log = function (...args) {
                        originalConsole.log.apply(console, args);
                        sendStatusMessage(args.join(' '));
                };

                console.error = function (...args) {
                        originalConsole.error.apply(console, args);
                        sendStatusMessage(`❌ ${args.join(' ')}`);
                };

                console.warn = function (...args) {
                        originalConsole.warn.apply(console, args);
                        sendStatusMessage(`⚠️ ${args.join(' ')}`);
                };

                console.info = function (...args) {
                        originalConsole.info.apply(console, args);
                        sendStatusMessage(`ℹ️ ${args.join(' ')}`);
                };

                // Simple string hashing function
                function hashString(str) {
                        let hash = 0;
                        for (let i = 0; i < str.length; i++) {
                                const char = str.charCodeAt(i);
                                hash = ((hash << 5) - hash) + char;
                                hash = hash & hash;
                        }
                        return hash.toString(36);
                };

                // Remove localStorage usage and replace with API calls
                const cache = {
                        set: function (text, cards) {
                                // Implement API call to save cache data
                                fetch('/ki/cache', {
                                        method: 'POST',
                                        headers: {
                                                'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({ text, cards })
                                }).catch(error => console.error('Cache save failed:', error));
                        },
                        get: async function (text) {
                                try {
                                        const response = await fetch(`/ki/cache?text=${encodeURIComponent(text)}`);
                                        if (!response.ok) return null;
                                        const data = await response.json();
                                        return data.cards;
                                } catch (e) {
                                        console.warn('Cache read failed:', e);
                                        return null;
                                }
                        },
                        clear: function () {
                                // Implement API call to clear cache data
                                fetch('/ki/cache', {
                                        method: 'DELETE',
                                }).catch(error => console.error('Cache clear failed:', error));
                        }
                };

                async function updateCurrentSessionName() {
                        const select = document.getElementById('session-history');
                        const textarea = document.querySelector('textarea[name="text"]');
                        const text = textarea.value;

                        if (text) {
                                const displayName = text.slice(0, 30) + (text.length > 30 ? '...' : '');
                                select.querySelector('option[value=""]').textContent = displayName;
                        } else {
                                const response = await fetch('/ki/session/cards');
                                const cards = await response.json();
                                if (cards && cards.length > 0) {
                                        const firstDeck = cards[0].deck;
                                        select.querySelector('option[value=""]').textContent = firstDeck + ' - Current Session';
                                } else {
                                        select.querySelector('option[value=""]').textContent = 'Current Session';
                                }
                        }
                }

                // Keyboard shortcut handling
                function handleKeyDown(event) {
                        // Check for cmd+enter (Mac) or alt+enter (Windows/Linux)
                        if ((event.metaKey || event.altKey) && event.key === 'Enter') {
                                event.preventDefault();
                                generateFlashcards();
                        }
                }

                document.addEventListener('keydown', handleKeyDown);

                // Restore text on page load
                document.addEventListener('DOMContentLoaded', function () {
                        // Remove ?new=true from URL if present
                        if (window.location.search.includes('new=true')) {
                                window.history.replaceState({}, '', '/ki');
                        }

                        const textarea = document.querySelector('textarea[name="text"]');
                        textarea.addEventListener('input', updateCurrentSessionName);

                        const savedText = sessionStorage.getItem('savedText');
                        if (savedText) {
                                textarea.value = savedText;
                                updateCurrentSessionName();
                        }

                        // Check if there is deck information in the session
                        fetch('/ki/status')
                                .then(response => response.json())
                                .then(data => {
                                        if (data.hasDeckInfo) {
                                                document.querySelector('.upload-button').classList.add('visible');
                                                // Fetch and display cards from session
                                                fetch('/ki/session/cards')
                                                        .then(response => response.json())
                                                        .then(cards => {
                                                                if (cards && cards.length > 0) {
                                                                        displayCards(cards);
                                                                }
                                                        })
                                                        .catch(error => console.error('Error fetching session cards:', error));
                                        } else {
                                                // Load and display saved cards from local storage as fallback
                                                const savedCards = localStorage.getItem('ki_last_response');
                                                if (savedCards) {
                                                        const cards = JSON.parse(savedCards);
                                                        displayCards(cards);
                                                }
                                        }
                                });
                });

                function displayCards(cards) {
                        const results = document.getElementById('results');
                        results.innerHTML = ''; // Clear existing content

                        const cardsContainer = document.createElement('div');
                        cardsContainer.className = 'cards-container';
                        results.appendChild(cardsContainer);

                        cards.forEach(card => {
                                const cardElement = document.createElement('div');
                                cardElement.className = 'virtual-item';

                                if (card.name) {
                                        cardElement.innerHTML = `
                                                <h3>${card.name}</h3>`;
                                } else {
                                        cardElement.innerHTML = `
                                                <details>
                                                        <summary>${card.front.replace(/src="([^"]+)"/g, (match, src) => {
                                                if (!src.startsWith('http') && !src.startsWith('/ki/media/')) {
                                                        return `src="/ki/media/${src}"`;
                                                }
                                                return match;
                                        })}</summary>
                                                        ${card.back ? `<p>${card.back.replace(/src="([^"]+)"/g, (match, src) => {
                                                if (!src.startsWith('http') && !src.startsWith('/ki/media/')) {
                                                        return `src="/ki/media/${src}"`;
                                                }
                                                return match;
                                        })}</p>` : '<p class="empty-back">No answer provided yet</p>'}
                                                        ${card.tags?.length ? `<p class="tags">${card.tags.join(', ')}</p>` : ''}
                                                </details>`;
                                }

                                cardsContainer.appendChild(cardElement);
                        });
                }

                class VirtualScroller {
                        constructor(container, itemHeight = 80) {
                                this.container = container;
                                this.items = [];
                                this.itemHeight = itemHeight;
                                this.itemHeights = new Map();
                                this.visibleItems = new Map();
                                this.lastScrollTop = 0;
                                this.totalHeight = 0;
                                this.renderQueue = [];
                                this.isRendering = false;
                                this.renderTimeout = null;

                                this.container.addEventListener('scroll', () => {
                                        if (this.renderTimeout) {
                                                clearTimeout(this.renderTimeout);
                                        }
                                        this.renderTimeout = setTimeout(() => this.onScroll(), 16);
                                });

                                this.resizeObserver = new ResizeObserver((entries) => {
                                        for (const entry of entries) {
                                                const index = parseInt(entry.target.dataset.index);
                                                if (!isNaN(index)) {
                                                        this.itemHeights.set(index, entry.contentRect.height);
                                                        this.updatePositions();
                                                }
                                        }
                                });
                        }

                        updatePositions() {
                                requestAnimationFrame(() => {
                                        let currentOffset = 0;
                                        for (const [index, element] of this.visibleItems.entries()) {
                                                const height = this.itemHeights.get(index) || this.itemHeight;
                                                element.classList.add('positioned');
                                                element.style.setProperty('--offset', `${currentOffset}px`);
                                                currentOffset += height + 8;
                                        }
                                        this.totalHeight = currentOffset;
                                        this.container.classList.add('scrollable');
                                        this.container.style.setProperty('--height', `${this.totalHeight}px`);
                                });
                        }

                        addItem(item) {
                                const index = this.items.length;
                                this.items.push(item);

                                const element = document.createElement('div');
                                element.className = 'virtual-item opacity-0';
                                element.dataset.index = index;
                                element.innerHTML = item;
                                this.container.appendChild(element);
                                this.visibleItems.set(index, element);
                                this.resizeObserver.observe(element);

                                requestAnimationFrame(() => {
                                        element.classList.remove('opacity-0');
                                        element.classList.add('fade-in');
                                });

                                if (!this.isRendering) {
                                        requestAnimationFrame(() => this.updatePositions());
                                }
                        }

                        destroy() {
                                this.resizeObserver.disconnect();
                                this.isRendering = false;
                                this.renderQueue = [];
                                this.visibleItems.forEach(element => element.remove());
                                this.visibleItems.clear();
                                this.items = [];
                                this.totalHeight = 0;
                                this.container.classList.remove('scrollable');
                                this.container.style.removeProperty('--height');
                        }

                        onScroll() {
                                if (!this.isRendering) {
                                        this.renderLoop();
                                }
                        }

                        renderLoop() {
                                if (this.renderQueue.length === 0) {
                                        this.isRendering = false;
                                        return;
                                }

                                this.isRendering = true;
                                const scrollTop = this.container.scrollTop;
                                const viewportHeight = this.container.clientHeight;
                                const bufferSize = 5;

                                let currentOffset = 0;
                                let startIndex = 0;

                                // Find the start index based on cumulative heights
                                for (let i = 0; i < this.items.length; i++) {
                                        const height = this.itemHeights.get(i) || this.itemHeight;
                                        if (currentOffset + height > scrollTop - (bufferSize * this.itemHeight)) {
                                                startIndex = i;
                                                break;
                                        }
                                        currentOffset += height + 8;
                                }

                                const endIndex = Math.min(
                                        this.items.length,
                                        startIndex + Math.ceil(viewportHeight / this.itemHeight) + bufferSize
                                );

                                // Process items in view
                                const toProcess = this.renderQueue
                                        .filter(idx => idx >= startIndex && idx <= endIndex)
                                        .slice(0, 5);

                                if (toProcess.length > 0) {
                                        toProcess.forEach(idx => {
                                                if (!this.visibleItems.has(idx)) {
                                                        const element = document.createElement('div');
                                                        element.className = 'virtual-item';
                                                        element.dataset.index = idx;
                                                        element.innerHTML = this.items[idx];
                                                        this.container.appendChild(element);
                                                        this.visibleItems.set(idx, element);
                                                        this.resizeObserver.observe(element);

                                                        // Add click listener for details elements
                                                        const details = element.querySelector('details');
                                                        if (details) {
                                                                details.addEventListener('toggle', () => {
                                                                        this.updatePositions();
                                                                });
                                                        }
                                                }
                                        });
                                        this.renderQueue = this.renderQueue.filter(i => !toProcess.includes(i));
                                        this.updatePositions();
                                }

                                // Clean up off-screen items
                                for (const [index, element] of this.visibleItems.entries()) {
                                        if (index < startIndex || index > endIndex) {
                                                this.resizeObserver.unobserve(element);
                                                element.remove();
                                                this.visibleItems.delete(index);
                                        }
                                }

                                if (this.renderQueue.length > 0) {
                                        requestAnimationFrame(this.renderLoop);
                                } else {
                                        this.isRendering = false;
                                }
                        }
                }

                async function generateFlashcards() {
                        const text = document.querySelector('textarea[name="text"]').value;
                        const files = document.getElementById('files').files;
                        const results = document.getElementById('results');
                        const cards = [];
                        let cardCount = 0;
                        let deckCount = 0;
                        let firstDeckName = 'Ki Deck'; // Default name
                        const startTime = performance.now();
                        let lastUpdateTime = startTime;
                        let timerInterval;
                        let currentController = null;

                        if (!text.trim() && files.length === 0) {
                                showToast('Please enter text or upload a file', 'error');
                                return;
                        }

                        // Clear previous results and storage when starting new generation
                        localStorage.removeItem('ki_last_response');

                        // Clean up any existing virtual scroller and EventSource
                        if (results._virtualScroller) {
                                results._virtualScroller.destroy();
                                results._virtualScroller = null;
                        }
                        if (window._eventSource) {
                                window._eventSource.close();
                                window._eventSource = null;
                        }

                        // Handle file uploads first if any
                        if (files.length > 0) {
                                const formData = new FormData();
                                for (const file of files) {
                                        formData.append('files', file);
                                        console.log('Uploading file:', file.name, file.size);
                                }

                                const uploadResponse = await fetch('/ki/upload', {
                                        method: 'POST',
                                        body: formData
                                }).catch(error => {
                                        console.error('Network error during upload:', error);
                                        showToast('Network error during file upload', 'error');
                                        throw error;
                                });

                                if (!uploadResponse.ok) {
                                        const errorText = await uploadResponse.text();
                                        console.error('Upload failed:', uploadResponse.status, errorText);
                                        showToast(`Upload failed: ${errorText || uploadResponse.statusText}`, 'error');
                                        throw new Error('Failed to upload files');
                                }

                                // Wait for upload to be processed
                                await new Promise(resolve => setTimeout(resolve, 500));
                        }

                        function updateTimer() {
                                const processingState = document.querySelector('.processing-state');
                                const timerEl = processingState?.querySelector('.timer');
                                if (timerEl) {
                                        const currentTime = performance.now();
                                        const totalSeconds = Math.floor((currentTime - startTime) / 1000);
                                        const minutes = Math.floor(totalSeconds / 60);
                                        const seconds = totalSeconds % 60;
                                        const timeString = minutes > 0 ?
                                                `${minutes}m ${seconds}s` :
                                                `${seconds}s`;

                                        timerEl.textContent = timeString;
                                        lastUpdateTime = currentTime;
                                }
                        }

                        // Start the timer after ensuring the processing state exists
                        timerInterval = setInterval(updateTimer, 1000);

                        try {
                                // Clear previous results and show loading, but preserve debug info if it exists
                                const debugEl = results.querySelector('.virtual-item.debug');
                                results.innerHTML = '';

                                const cardsContainer = document.createElement('div');
                                cardsContainer.className = 'cards-container';
                                results.appendChild(cardsContainer);

                                // Re-add debug info if it existed
                                if (debugEl) {
                                        results.insertBefore(debugEl, cardsContainer);
                                }

                                const virtualScroller = new VirtualScroller(cardsContainer);
                                results._virtualScroller = virtualScroller;

                                // Show processing state
                                const processingState = document.createElement('div');
                                processingState.className = 'processing-state';
                                processingState.innerHTML = `
                                    <div class="icon">📝</div>
                                    <div class="content">
                                        <div class="title">
                                            Processing content
                                            <div class="spinner"></div>
                                            <span class="timer">0s</span>
                                        </div>
                                        <div class="subtitle">
                                            <span class="status-message">Starting process...</span>
                                        </div>
                                        <div class="progress">
                                            <div class="progress-bar"></div>
                                        </div>
                                        ${files.length ? `
                                            <div class="file-preview">
                                                <div class="icon">📁</div>
                                                <div class="name">${Array.from(files).map(f => f.name).join(', ')}</div>
                                            </div>
                                        ` : ''}
                                        ${text.trim() ? `
                                            <div class="file-preview">
                                                <div class="icon">📄</div>
                                                <div class="name">${text.slice(0, 100)}${text.length > 100 ? '...' : ''}</div>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <button class="cancel-button" onclick="cancelProcessing()">Cancel</button>
                                `;
                                cardsContainer.insertBefore(processingState, cardsContainer.firstChild);

                                // Create EventSource for SSE
                                currentController = new AbortController();
                                const response = await fetch('/ki/generate', {
                                        method: 'POST',
                                        headers: {
                                                'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({
                                                text,
                                                files: Array.from(files).map(f => f.name)
                                        }),
                                        signal: currentController.signal
                                });

                                if (!response.ok) {
                                        throw new Error(`HTTP error! status: ${response.status}`);
                                }

                                const reader = response.body.getReader();
                                const decoder = new TextDecoder();
                                let buffer = '';

                                // Start processing cards
                                while (true) {
                                        const { value, done } = await reader.read();
                                        if (done) break;

                                        buffer += decoder.decode(value, { stream: true });
                                        const events = buffer.split('\n\n');
                                        buffer = events.pop() || '';

                                        for (const event of events) {
                                                const lines = event.split('\n');
                                                const eventType = lines.find(line => line.startsWith('event:'))?.replace('event:', '').trim();
                                                const data = lines.find(line => line.startsWith('data:'))?.replace('data:', '').trim();

                                                if (!eventType || !data) continue;

                                                if (eventType === 'card') {
                                                        try {
                                                                const card = JSON.parse(data);
                                                                cards.push(card);
                                                                console.log('[CARD RECEIVED]', card);

                                                                if (card.name && !card.front && !card.back) {
                                                                        deckCount++;
                                                                } else {
                                                                        cardCount++;
                                                                }

                                                                const cardElement = document.createElement('div');
                                                                cardElement.className = 'virtual-item';

                                                                if (card.name) {
                                                                        cardElement.innerHTML = `
                                                                                <h3>${card.name}</h3>`;
                                                                } else {
                                                                        cardElement.innerHTML = `
                                                                                <details>
                                                                                        <summary>${card.front.replace(/src="([^"]+)"/g, (match, src) => {
                                                                                if (!src.startsWith('http') && !src.startsWith('/ki/media/')) {
                                                                                        return `src="/ki/media/${src}"`;
                                                                                }
                                                                                return match;
                                                                        })}</summary>
                                                                                        ${card.back ? `<p>${card.back.replace(/src="([^"]+)"/g, (match, src) => {
                                                                                if (!src.startsWith('http') && !src.startsWith('/ki/media/')) {
                                                                                        return `src="/ki/media/${src}"`;
                                                                                }
                                                                                return match;
                                                                        })}</p>` : '<p class="empty-back">No answer provided yet</p>'}
                                                                                        ${card.tags?.length ? `<p class="tags">${card.tags.join(', ')}</p>` : ''}
                                                                                </details>`;
                                                                }

                                                                cardsContainer.appendChild(cardElement);
                                                        } catch (error) {
                                                                console.error('Failed to parse card:', error);
                                                        }
                                                } else if (eventType === 'status') {
                                                        try {
                                                                const statusData = JSON.parse(data);
                                                                const message = statusData.message || statusData;
                                                                const statusMessages = document.querySelector('.status-message');
                                                                if (statusMessages) {
                                                                        const newMessage = document.createElement('div');
                                                                        newMessage.textContent = message;
                                                                        newMessage.classList.add('status-message');
                                                                        statusMessages.appendChild(newMessage);

                                                                        // Keep only last 3 messages
                                                                        while (statusMessages.children.length > 3) {
                                                                                statusMessages.removeChild(statusMessages.firstChild);
                                                                        }

                                                                        // Scroll to latest message
                                                                        newMessage.scrollIntoView({ behavior: 'smooth' });
                                                                }
                                                        } catch (error) {
                                                                console.error('Failed to parse status:', error);
                                                        }
                                                } else if (eventType === 'error') {
                                                        clearInterval(timerInterval);
                                                        const errorData = JSON.parse(data);
                                                        throw new Error(errorData.error || 'Failed to generate flashcards');
                                                } else if (eventType === 'complete') {
                                                        clearInterval(timerInterval);
                                                        const processingState = document.querySelector('.processing-state');

                                                        // Remove any remaining processing messages
                                                        if (processingState) {
                                                                processingState.classList.add('cancelled');
                                                                setTimeout(() => {
                                                                        processingState.remove();
                                                                }, 1500);
                                                        }

                                                        const endTime = performance.now();
                                                        const totalTime = Math.max(1, Math.floor((endTime - startTime) / 1000));
                                                        const minutes = Math.floor(totalTime / 60);
                                                        const seconds = totalTime % 60;
                                                        const timeString = minutes > 0 ?
                                                                `${minutes}m ${seconds}s` :
                                                                `${seconds}s`;

                                                        if (processingState) {
                                                                processingState.classList.add('hidden');
                                                                processingState.innerHTML = `
                                                                <div class="status">✅ ${deckCount} decks • ${cardCount} cards</div>
                                                            `;
                                                                setTimeout(() => {
                                                                        processingState.classList.add('hidden');
                                                                }, 3000);
                                                        }

                                                        // Cache if needed
                                                        if (files.length === 0 && text.trim() && cards.length > 0) {
                                                                await cache.set(text, cards);
                                                                localStorage.setItem('ki_last_response', JSON.stringify(cards));
                                                                await updateCurrentSessionName();
                                                        }
                                                }
                                        }
                                }
                        } catch (error) {
                                console.error('Error:', error);
                                clearInterval(timerInterval);
                                const errorDiv = document.createElement('div');
                                errorDiv.className = 'error';
                                errorDiv.textContent = `Error: ${error.message}`;
                                results.innerHTML = '';
                                results.appendChild(errorDiv);
                        }
                }

                // Debug toggle
                function toggleDebug() {
                        const current = localStorage.getItem('debug') === 'true';
                        const newState = !current;
                        localStorage.setItem('debug', newState.toString());

                        const button = document.getElementById('debug-button');
                        if (button) {
                                button.classList.toggle('debug-active', newState);
                        }
                }

                // Initialize debug button state
                document.addEventListener('DOMContentLoaded', function () {
                        const isDebug = localStorage.getItem('debug') === 'true';
                        const button = document.getElementById('debug-button');
                        if (button) {
                                button.classList.toggle('debug-active', isDebug);
                        }
                });

                function showToast(message, type = 'info') {
                        const toast = document.createElement('div');
                        toast.className = 'toast ' + type;
                        toast.textContent = message;
                        document.body.appendChild(toast);

                        requestAnimationFrame(() => {
                                toast.classList.add('visible');
                        });

                        setTimeout(() => {
                                toast.classList.remove('visible');
                                setTimeout(() => toast.remove(), 300);
                        }, 2000);
                }

                document.addEventListener('DOMContentLoaded', function () {
                        const fileInput = document.getElementById('files');
                        if (fileInput) {
                                fileInput.addEventListener('change', function (e) {
                                        if (e.target.files.length > 0) {
                                                generateFlashcards();
                                        }
                                });
                        }

                        const processingState = document.querySelector('.processing-state');
                        if (processingState) {
                                processingState.classList.add('hidden');
                        }

                        const editorContainer = document.querySelector('.editor-container');
                        if (editorContainer) {
                                ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                                        editorContainer.addEventListener(eventName, preventDefaults, false);
                                        document.body.addEventListener(eventName, preventDefaults, false);
                                });

                                ['dragenter', 'dragover'].forEach(eventName => {
                                        editorContainer.addEventListener(eventName, highlight, false);
                                });

                                ['dragleave', 'drop'].forEach(eventName => {
                                        editorContainer.addEventListener(eventName, unhighlight, false);
                                });

                                editorContainer.addEventListener('drop', handleDrop, false);
                        }

                        loadSessionHistory();
                });

                // Add download function before the last script tag
                async function downloadDeck(name) {
                        try {
                                const response = await fetch('/ki/download', {
                                        method: 'POST',
                                        headers: {
                                                'Content-Type': 'application/json',
                                        },
                                        body: JSON.stringify({ name })
                                });

                                if (!response.ok) {
                                        const errorData = await response.json();
                                        throw new Error(errorData.error || 'Failed to download deck');
                                }

                                const blob = await response.blob();
                                if (blob.size === 0) {
                                        throw new Error('Empty deck file received');
                                }

                                const url = window.URL.createObjectURL(blob);
                                const a = document.createElement('a');
                                a.href = url;
                                a.download = name.endsWith('.apkg') ? name : `${name}.apkg`;
                                document.body.appendChild(a);
                                a.click();
                                window.URL.revokeObjectURL(url);
                                a.remove();
                        } catch (error) {
                                console.error('Download error:', error);
                                showToast(error.message || 'Failed to download deck', 'error');
                        }
                }

                function cancelProcessing() {
                        if (currentController) {
                                currentController.abort();
                                currentController = null;

                                const processingState = document.querySelector('.processing-state');
                                if (processingState) {
                                        processingState.classList.add('cancelled');
                                        setTimeout(() => {
                                                processingState.remove();
                                        }, 1500);
                                }
                        }
                }

                async function deleteSession() {
                        try {
                                const select = document.getElementById('session-history');
                                const sessionId = select.value;
                                if (!sessionId) {
                                        showToast('No session selected', 'error');
                                        return;
                                }

                                await fetch(`/ki/session/delete?sessionId=${sessionId}`, { method: 'DELETE' });
                                // Clear UI
                                document.querySelector('.cards-container').innerHTML = '';
                                document.querySelector('textarea[name="text"]').value = '';
                                document.getElementById('session-history').value = '';
                                showToast('Session deleted successfully', 'success');
                                // Refresh session history
                                await loadSessionHistory();
                        } catch (error) {
                                console.error('Failed to delete session:', error);
                                showToast('Failed to delete session', 'error');
                        }
                }

                function updateStatusMessage(message) {
                        if (statusMessageEl) {
                                statusMessageEl.textContent = message;
                        }
                }

                function updateProcessingState(message, progress) {
                        if (processingStateEl) {
                                const timerEl = processingStateEl.querySelector('.timer');
                                if (timerEl) {
                                        timerEl.textContent = message;
                                }
                                if (progress !== undefined) {
                                        const progressBar = processingStateEl.querySelector('.progress-bar');
                                        if (progressBar) {
                                                progressBar.style.width = `${progress}%`;
                                        }
                                }
                        }
                }

                async function downloadDeckWithName() {
                        try {
                                const response = await fetch('/ki/session/cards');
                                const cards = await response.json();
                                if (cards && cards.length > 0) {
                                        const deckName = cards[0].deck || 'Ki Deck';
                                        downloadDeck(deckName);
                                } else {
                                        downloadDeck('Ki Deck');
                                }
                        } catch (error) {
                                console.error('Error getting deck name:', error);
                                downloadDeck('Ki Deck');
                        }
                }

                async function loadSessionHistory() {
                        const response = await fetch('/ki/session/history');
                        const data = await response.json();
                        const select = document.getElementById('session-history');
                        select.innerHTML = '<option value="">Current Session</option>';

                        for (const session of data.sessions) {
                                const sessionResponse = await fetch(`/ki/session/${session.id}`);
                                const sessionData = await sessionResponse.json();

                                let displayName = new Date(session.createdAt).toLocaleString();
                                if (sessionData.text) {
                                        displayName = sessionData.text.slice(0, 30) + (sessionData.text.length > 30 ? '...' : '');
                                } else if (sessionData.cards && sessionData.cards.length > 0) {
                                        const firstDeck = sessionData.cards[0].deck;
                                        displayName = firstDeck + ' - ' + displayName;
                                }

                                const option = document.createElement('option');
                                option.value = session.id;
                                option.textContent = displayName;
                                if (session.id === data.currentSessionId) {
                                        option.selected = true;
                                }
                                select.appendChild(option);
                        }
                }

                async function loadSession(sessionId) {
                        try {
                                if (!sessionId) {
                                        // Clear UI for current session
                                        document.querySelector('textarea[name="text"]').value = '';
                                        document.querySelector('.cards-container').innerHTML = '';
                                        showToast('Switched to current session', 'success');
                                        return;
                                }

                                const response = await fetch(`/ki/session/${sessionId}`);
                                if (!response.ok) throw new Error('Failed to load session');

                                const data = await response.json();
                                displayCards(data.cards);

                                if (data.text) {
                                        document.querySelector('textarea[name="text"]').value = data.text;
                                }
                                showToast('Session loaded successfully', 'success');
                        } catch (error) {
                                console.error('Failed to load session:', error);
                                showToast('Failed to load session', 'error');
                        }
                }

                async function startNewSession() {
                        try {
                                // Clear UI immediately
                                document.querySelector('.cards-container').innerHTML = '';
                                document.querySelector('textarea[name="text"]').value = '';
                                document.getElementById('session-history').value = '';

                                // Create new session
                                window.location.href = '/ki?new=true';
                        } catch (error) {
                                console.error('Failed to start new session:', error);
                                showToast('Failed to start new session', 'error');
                        }
                }

                function preventDefaults(e) {
                        e.preventDefault();
                        e.stopPropagation();
                }

                function highlight(e) {
                        const editorContainer = document.querySelector('.editor-container');
                        if (editorContainer) {
                                editorContainer.classList.add('drag-over');
                        }
                }

                function unhighlight(e) {
                        const editorContainer = document.querySelector('.editor-container');
                        if (editorContainer) {
                                editorContainer.classList.remove('drag-over');
                        }
                }

                function handleDrop(e) {
                        const dt = e.dataTransfer;
                        const files = dt.files;
                        const fileInput = document.getElementById('files');

                        if (fileInput && files.length > 0) {
                                fileInput.files = files;
                                generateFlashcards();
                        }
                }
        </script>
        </div>
</body>

</html>